A atividade de escalonamento pode ser otimizada para vários objetivos, entre os quais podemos citar:
\begin{itemize}
	\item Maximinizar quantidade de trabalho realizada por unidade de tempo;
	\item Minimizar tempo no qual trabalhos ficam esperando para serem executados;
	\item Minimizar tempo entre um conjunto de trabalhos estarem prontos para serem executados até o fim da execução do conjunto(latência ou tempo de resposta);
	\item Distribuir de forma justa o tempo que cada um dos trabalhos terão de uso de um recurso escasso.
\end{itemize}

Esses objetivos são, às vezes, contraditórios. Na prática prioriza-se um conjunto de métricas como base para otimização. Por exemplo o GNU/Linux utilizada o \acrfull{CFS}, que se baseia no algoritmo \textit{Fair queuing}. Como o nome já diz, o foco desse escalonador está em ser justo. Internamente utiliza-se uma árvore rubro-negra indexados pelo tempo gasto no processador. Para ser justo, o tempo máximo de cada processo fica em execução interrupta é o quociente do tempo que o processo ficou aguardando para ser executado pelo número total de processos.

\section{Algoritmo proposto}

O escalonador proposto para implementação segue a ideia básica de escalonamento de listas. Haverão três listas: lista de tarefas a serem feitas, lista de \acrshort{CPU}s disponíveis e lista de \acrshort{GPU}s disponíveis.
A lista de tarefas é ordenada por tempo previsto de execução, que é dado por um estimativa a partir do programa a ser rodado e do arquivo de entrada. Essa ordenação será em ordem decrescente de tempo previsto. A lista de \acrshort{CPU}s disponíveis é ordenada com base na frequência e no número de núcleos. A lista de \acrshort{GPU}s tem sua ordem determinada pela quantidade de operações em pontos flutuante consegue realizar por segundo.

O escalonamento ocorre da seguinte forma, como ilustrado na figura \ref{Escalonamento} :
\begin{enumerate}
	\item Existem tarefas que podem ser executadas nos recursos disponíveis?
	\item Se sim, obtenha o processo que está no topo da lista.
	\begin{enumerate}
		\item É capaz de rodar em GPU?
		\item Se sim:
		\begin{enumerate}
			\item O tempo prevista para rodá-lo na melhor \acrshort{GPU} disponível é melhor que o tempo previsto para rodá-lo na melhor \acrshort{CPU} disponível?
			\item Se sim, escalone-o para nessa \acrshort{GPU}.
			\item Se não, escalone-o para na melhor \acrshort{CPU} disponível.
		\end{enumerate}
		\item Se não, escalone-o na melhor \acrshort{CPU} disponível.
		\item Remova a tarefa e o recurso alocado de suas respectivas listas.
	\end{enumerate}
	\item Se não, encerre o escalonamento.
	\item Volte para a regra 1.
\end{enumerate}


\begin{figure}[htbp]
%	\centerline{\includegraphics[scale=0.04]{img/EscalonadorProposto.png}}
	\centerline{\includegraphics[scale=0.032]{img/EscalonadorProposto2.png}}
	\caption{Diagrama de Funcionamento do Algoritmo de Escalonamento.}
	\label{Escalonamento}
\end{figure}

Observa-se que, para o algoritmo supracitado seja válido, pressupõe-se, que toda tarefa do algoritmo é capaz de rodar em CPU. O que é correto, pois atualmente todas as tarefas do BioNimbuZ rodam em \acrshort{CPU}. O pressuposto simplifica o primeiro passo do algoritmo, pois se a lista de \acrshort{CPU}s não estiver vazia, essa condição é automaticamente satisfeita. Futuramente pode ser necessário adaptá-lo para ser capaz de lidar com tarefas que só são capazes de serem executadas em \acrshort{GPU}.

Como trabalho futuro, se o BioNimbuZ obtiver suporte executação de uma mesma tarefa de forma distribuída, uma pequena modificação que pode ser feita no algoritmo supracitado é: ao invés de remover as tarefas escalonadas da lista de tarefas, colocá-las no fim dessa mesma lista. Fará com que o escalonamento seja interrompido apenas quando todos os recursos disponíveis forem alocados, pois sempre haverá tarefas para serem alocadas.

